# Set up development server
Clone the repo
```
git clone https://github.com/toanhminh0412/mystore.git
cd mystore
```

From now on, `mystore` will be our root directory. Install python packages into a virtual environment:
```
python3 -m venv venv
. venv/bin/activate
pip install -r requirements.txt
```

Start a PostgreSQL database (read the **Assumptions** section for why):
```
docker run --name mystore-postgres \
    -e POSTGRES_DB=mystore \
    -e POSTGRES_USER=mystore \
    -e POSTGRES_PASSWORD=supersecretpassword \
    -p 5432:5432 \
    -d postgres
```

Create necessary environment variables in `mystore/.env`:
```
cat > mystore/.env << 'EOF'
SECRET_KEY=supersecretkey       # Please change this to something secure. You can generate one by running 'python3 -c "from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())"'
DEBUG=true
ALLOWED_HOSTS=localhost,127.0.0.1

POSTGRES_HOST=localhost
POSTGRES_DB=mystore
POSTGRES_USER=mystore
POSTGRES_PASSWORD=supersecretpassword
EOF
```

Perform a database migration:
```
python3 manage.py migrate
```

**(Optional)** Generate data for the app. If you want to use the Django's admin dashboard to manually create data, feel free to skip this step. Use the `populatedata` management command to generate test data (You can modify `data/products.json` to make changes to the data):
```
python3 manage.py populatedata
```

Run Django's development server on port 8000:
```
python3 manage.py runserver
```
or on other port (e.g. 4001):
```
python3 manage.py runserver 127.0.0.1:4001
```
Visit the app on `http://127.0.0.1:<port>`.

# Assumptions
1. **PostgreSQL Database**: This project is built to run with Postgres because we build a [GIN index](https://www.postgresql.org/docs/current/gin.html) in Postgres.
2. **Relationships between models**: Assuming one product can have one category while multiple products can fall into one category. One product can have multiple tags and one tag can be attached to multiple products.

# Design decisions
This section explains how I implemented the search and filter functionalities.

**1. Description**
- Use `models.TextField` to store description due to the uncertain of length. Therefore, we'd have to support full-text search for the description field.
- Use GIN index for description search as it's efficient for full-text search.
- Implementation for GIN index is briefly described as follows: create a tsvector field `description_tsv` that is auto-generated on description saves, create a GIN index for this field, implement searches using this field.

**2. Category and tags**
- Categories and tags are filtered by their ids because Postgres auto-index table primary keys.

# Improvements to be made
This project is missing some important aspects of a good software. The followings can be added immediately on further development:
- **Code quality + unit testing**: pylint and unit tests + Gitlab CI or Github workflow for test automation
- **Reproducibility**: Create a `Dockerfile` and related files for easy software reproducibility on other systems
- **Frontend**: Use a frontend framework to provide a smooth AJAX experience to users and for code maintainability 

# AI usage
1. All AI-related VS code extensions (e.g. Github Copilot) were disabled for the project. However, ChatGPT and AI responses generated by Google were used for concept-related answers and code syntax (one-liners). Comments are provided where AI was used for the code.
2. `data/products.json`, the test data, was fully genereated by AI.
